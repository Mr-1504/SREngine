ShaderType Spatial;

PolygonMode Fill;
CullMode Back;
DepthCompare LessOrEqual;
PrimitiveTopology TriangleList;
BlendEnabled false;
DepthWrite true;
DepthTest true;

[[uniform], [public]] vec4 color;
[[uniform], [public]] sampler2D diffuse;

[[uniform]] sampler2D shadowMap;

[[shared]] vec3 normal;
[[shared]] vec3 fragPos;
[[shared]] vec4 fragPosLightSpace;

float ShadowCalculation(vec4 fragPosLightSpace) {
    // Выполняем деление перспективы
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;

    // Преобразуем в диапазон [0,1]
    projCoords = projCoords * 0.5 + 0.5;

    // Получаем наиболее близкое значение глубины, исходя из перспективы с точки зрения источника света (используя диапазон [0,1] fragPosLight в качестве координат)
    float closestDepth = texture(shadowMap, projCoords.xy).r;

    // Получаем глубину текущего фрагмента, исходя из перспективы с точки зрения источника света
    float currentDepth = projCoords.z;

    // Проверяем, находится ли текущий фрагмент в тени
    if (currentDepth > closestDepth) {
        return 1.0;
    }

    return 0.0;
}

void fragment() {
    vec3 diffuseColor = texture(diffuse, UV).rgb * color.rgb;
    vec3 normal = normalize(normal);
    vec3 lightColor = vec3(1.0);
    // ambient
    vec3 ambient = 0.15 * diffuseColor;
    // diffuse
    vec3 lightDir = normalize(DIRECTIONAL_LIGHT_POSITION - fragPos);
    float diff = max(dot(lightDir, normal), 0.0);
    vec3 diffuseLight = diff * lightColor;
    // specular
    vec3 viewDir = normalize(VIEW_POSITION - fragPos);
    vec3 halfwayDir = normalize(lightDir + viewDir);
    float spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;
    // calculate shadow
    float shadow = ShadowCalculation(fragPosLightSpace);
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuseLight + specular)) * diffuseColor;

	COLOR = vec4(lighting, 1.0);
}

void vertex() {
    fragPos = vec3(MODEL_MATRIX * vec4(VERTEX, 1.0));
    normal = transpose(inverse(mat3(MODEL_MATRIX))) * NORMAL;
    fragPosLightSpace = LIGHT_SPACE_MATRIX * vec4(fragPos, 1.0);

    OUT_POSITION = PROJECTION_MATRIX * VIEW_MATRIX * MODEL_MATRIX * vec4(VERTEX, 1.0);
}