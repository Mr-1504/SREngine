ShaderType PostProcessing;

PolygonMode Fill;
CullMode Back;
DepthCompare LessOrEqual;
PrimitiveTopology TriangleStrip;
BlendEnabled true;
DepthWrite false;
DepthTest true;

[[shared]] vec2 UV;

[[shared]] vec2 z = vec2(0.000035, -0.000035);
[[shared]] vec2 v = vec2(0.000035, -0.000035);
[[shared]] vec2 e = vec2(0.000035, -0.000035);
[[shared]] float t;
[[shared]] float tt;
[[shared]] float b;
[[shared]] float g;
[[shared]] float g2;
[[shared]] float bb;
[[shared]] vec3 np;
[[shared]] vec3 bp;
[[shared]] vec3 pp;
[[shared]] vec3 po;
[[shared]] vec3 no;
[[shared]] vec3 al;
[[shared]] vec3 ld;


float bo(vec3 p, vec3 r) {
    p = abs(p) - r;
    return max(max(p.x, p.y), p.z);
}

mat2 r2(float r) {
    return mat2(cos(r), sin(r), -sin(r), cos(r));
}

vec2 fb(vec3 p, float m) {
  p.y += bb * 0.05;
  vec2 h, t = vec2(bo(p, vec3(5, 1, 3)), 3);
  t.x = max(t.x, -(length(p) - 2.5));
  t.x = max(abs(t.x) - 0.2, (p.y - 0.4));
  h = vec2(bo(p, vec3(5, 1, 3)), 6);
  h.x = max(h.x, -(length(p) - 2.5));
  h.x = max(abs(h.x) - 0.1, (p.y - 0.5));
  if (t.x >= h.x) {
      t = h;
  }
  h = vec2(bo(p + vec3(0, 0.4, 0), vec3(5.4, 0.4, 3.4)), m);
  h.x = max(h.x, -(length(p) - 2.5));
  if (t.x >= h.x) {
      t = h;
  }
  h = vec2(length(p) - 2.0, m);
  if (t.x >= h.x) {
      t = h;
  }
  t.x *= 0.7;
  return t;
}

vec2 mp(vec3 p) {
  pp = bp = p;
  bp.yz = p.yz *= r2(sin(pp.x * 0.3 - tt * 0.5) * 0.4);
  p.yz *= r2(1.57);
  b = sin(pp.x * 0.2 + tt);
  bb = cos(pp.x * 0.2 + tt);
  p.x = mod(p.x - tt * 2.0, 10.0) - 5.0;
  vec4 np = vec4(p * 0.4, 0.4);
  for(int i = 0; i < 4; i++){
    np.xyz = abs(np.xyz) - vec3(1, 1.2, 0);
    np.xyz = 2.0 * clamp(np.xyz, -vec3(0), vec3(2, 0., 4.3 + bb)) - np.xyz;
    np = np * (1.3) / clamp(dot(np.xyz, np.xyz), 0.1, .92);
  }
  vec2 h, t = fb(abs(np.xyz) - vec3(2, 0, 0), 5.);
  t.x /= np.w;
  t.x = max(t.x, bo(p, vec3(5, 5, 10)));
  np *= 0.5; np.yz *= r2(.785); np.yz += 2.5;
  h = fb(abs(np.xyz) - vec3(0, 4.5, 0), 7.);
  h.x = max(h.x, -bo(p, vec3(20, 5, 5)));
  h.x /= np.w * 1.5;
  if (t.x >= h.x) {
      t = h;
  }
  h = vec2(bo(np.xyz, vec3(0.0, b * 20., 0.0)), 6);
  h.x /= np.w * 1.5;
  g2 += 0.1 / (0.1 * h.x * h.x * (1000.0- b * 998.));
  if (t.x >= h.x) {
      t = h;
  }
  h = vec2(0.6 * bp.y + sin(p.y * 5.) * 0.03, 6);
  if (t.x >= h.x) {
      t = h;
  }
  h = vec2(length(cos(bp.xyz * 0.6+ vec3(tt, tt, 0))) + 0.003, 6);
  g += 0.1 / (0.1 * h.x * h.x * 4000.);
  if (t.x >= h.x) {
      t = h;
  }
  return t;
}

vec2 tr( vec3 ro, vec3 rd )
{
  vec2 h, t = vec2(.1);
  for(int i = 0; i < 128; i++){
    h = mp(ro + rd * t.x);
    if(h.x < .0001 || t.x > 40.) {
        break;
    }
    t.x += h.x;
    t.y = h.y;
  }
  if(t.x > 40.) {
    t.y = 0.;
  }
  return t;
}

void fragment()
{
  vec2 uv = (fragCoord.xy / RESOLUTION.xy - 0.5) / vec2(RESOLUTION.y / RESOLUTION.x, 1);
  tt = mod(TIME, 62.8318);
  vec3 ro = mix(vec3(1), vec3(-0.5, 1, -1), ceil(sin(tt * .5))) * vec3(10, 2.8 + 0.75 * smoothstep(-1.5, 1.5, 1.5 * cos(tt + 0.2)), cos(tt * 0.3) * 3.1);
  vec3 cw = normalize(vec3(0) - ro);
  vec3 cu = normalize(cross(cw, normalize(vec3(0, 1, 0))));
  vec3 cv = normalize(cross(cu, cw));
  vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, .5)), co, fo;
  ld = normalize(vec3(.2, .4, -.3));
  vec3 fo = vec3(.1, .2, .3) - length(uv) * 0.1- rd.y * .2;
  vec3 co = fo;
  vec3 z = tr(ro, rd);
  t = z.x;
  if(z.y > 0.) {
    po = ro + rd * t;
    no = normalize(e.xyy * mp(po + e.xyy).x + e.yyx * mp(po + e.yyx).x + e.yxy * mp(po + e.yxy).x + e.xxx * mp(po + e.xxx).x);
    al = mix(vec3(0.1, 0.2, .4), vec3(0.1, 0.4, .7), 0.5+ 0.5 * sin(bp.y * 7.));
    if(z.y < 5.) {
        al = vec3(0);
    }
    if(z.y > 5.) {
        al = vec3(1);
    }
    if(z.y > 6.) {
        al = mix(vec3(1, .5, 0), vec3(.9, .3, .1), 0.5+ 0.5* sin(bp.y * 7.));
    }
    float dif = max(0., dot(no, ld));
    float fr = pow(1.0 + dot(no, rd), 4.);
    float sp = pow(max(dot(reflect(-ld, no), -rd), 0.), 40.);
    //co = mix(sp + mix(vec3(.8), vec3(1), abs(rd)) * al * ((clamp(mp(po + no * 0.1).x / 0.1, 0.0, 1.0) * (clamp(mp(po + no * 0.2).x / 0.2, 0.0, 1.0) + 0.2) * (dif + smoothstep(0.0, 1.0, mp(po + ld * 2.0).x / 2.0)), fo, min(fr, 0.2));
    co = mix(sp + mix(vec3(.8), vec3(1), abs(rd)) * al * (clamp(mp(po + no * .1).x / .1, 0., 1.) * clamp(mp(po + no * .2).x / .2, 0., 1.) + .2) * (dif + smoothstep(0., 1., mp(po + ld * 2.).x / 2.)), fo, min(fr, .2));
    co = mix(fo, co, exp(-.0003 * t * t * t));
  }
  COLOR = vec4(pow(co + g * 0.2+ g2 * mix(vec3(1., .5, 0), vec3(.9, .3, .1), 0.5+ 0.5* sin(bp.y * 3.)), vec3(0.65)), 1);
}

void vertex() {
    vec3 vertices[4] = {
        vec3(-1.0,  1.0, 0.0),
        vec3(-1.0, -1.0, 0.0),
        vec3( 1.0,  1.0, 0.0),
        vec3( 1.0, -1.0, 0.0),
    };

    vec2 uv[4] = {
        vec2(0.0, 1.0),
        vec2(0.0, 0.0),
        vec2(1.0, 1.0),
        vec2(1.0, 0.0),
    };

    UV = uv[VERTEX_INDEX];
    vec3 p = vertices[VERTEX_INDEX];

    OUT_POSITION = vec4(p, 1.0);
}